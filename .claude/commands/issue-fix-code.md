# Issue Fix Code Command

**描述**: 通过修改代码来自动修复 issue 并生成修复报告

**重要说明**: 此命令用于**代码修复**，会修改 `lib/`、`components/` 等代码目录中的文件。如果需要通过更新文档来修复问题，请使用 `/issue-fix-doc` 命令。

**用法**:

- `/issue-fix-code {issue_id}` - 使用推荐方案修复代码
- `/issue-fix-code {issue_id} {方案编号}` - 使用 report 中指定方案修复代码（如：方案一、方案1、方案2）
- `/issue-fix-code {issue_id} {自定义方案描述}` - 使用自定义方案修复代码

**参数**:

- `issue_id`: Issue 目录名（如：P0-003-mindmap-persistence-draft）
- `方案参数`: 可选，有三种形式：
  - **方案编号**: 如 "方案一"、"方案1"、"方案2" - 使用 report 中的对应方案
  - **自定义描述**: 详细的修复方案说明 - 不使用 report 中的任何方案，而是按照描述进行修复
  - **省略**: 使用 report 中的推荐方案

---

## 任务执行流程

你需要按照以下步骤自动化修复 issue：

### 1. 解析和验证参数

从用户输入中提取：

- `issue_id`: 必需参数
- `solution_param`: 可选参数，默认使用推荐方案

**参数解析示例**:

- `/issue-fix-code P0-003-mindmap-persistence-draft`
  → issue_id = "P0-003-mindmap-persistence-draft", 使用推荐方案修复代码

- `/issue-fix-code P0-003-mindmap-persistence-draft 方案一`
  → 使用 report 中的方案一修复代码

- `/issue-fix-code P0-004-mindmap-persistence-draft 方案2`
  → 使用 report 中的方案二（方案2）修复代码

- `/issue-fix-code P0-005-mindmap-persistence-draft 在 lib/types/persistence.ts 中添加新的类型定义`
  → 使用自定义方案描述修复代码

**参数识别逻辑**:

识别 `solution_param` 的类型：

1. **省略参数**: 如果没有提供 solution_param，使用推荐方案
2. **方案编号**: 如果包含"方案"关键词（如"方案一"、"方案1"、"方案二"），从 report 中查找对应方案
3. **自定义描述**: 如果不是方案编号格式，则视为自定义修复方案描述

**验证**:

- 检查 `.claude/issues/{issue_id}/` 目录是否存在
- 检查 `.claude/issues/{issue_id}/report.md` 文件是否存在
- 如果不存在，输出错误信息并终止

### 2. 读取 Issue Report

读取 `.claude/issues/{issue_id}/report.md` 文件，提取以下信息：

**必须提取的信息**:

- 问题描述和位置
- 所有修复方案（方案一、方案二、方案三等）
- 推荐方案（通常在 "## 推荐方案" 章节）
- 相关文档列表（在 "## 相关文档" 章节）
- 后续行动步骤（在 "## 后续行动步骤" 章节）

**解析修复方案**:

根据 `solution_param` 的类型选择修复方案：

1. **使用推荐方案**（`solution_param` 省略）:
   - 查找 "## 推荐方案" 章节
   - 提取推荐的方案编号（如："推荐使用方案一"）
   - 定位并提取该方案的完整内容

2. **使用指定方案**（`solution_param` 是方案编号）:
   - 识别方案编号（支持"方案一"、"方案1"、"方案二"、"方案2"等格式）
   - 在 report 中查找 "### 方案一" 或 "### 方案二" 等章节
   - 提取该方案的完整内容
   - 如果方案不存在，输出错误并列出可用方案

3. **使用自定义方案**（`solution_param` 是描述文本）:
   - 不查找 report 中的方案
   - 将 `solution_param` 作为修复指令
   - 结合问题描述和相关文档，理解并执行自定义方案

### 3. 读取相关文档

从 report 的 "## 相关文档" 章节提取所有文档路径，并读取这些文档：

**文档路径格式**:

```
- `docs/design/database-schema.md` - 第 136-165 行（mindmap_nodes 表定义）
- `docs/draft/mindmap-persistence-requirements.md` - 第 228-236、772 行（问题代码位置）
```

**读取策略**:

- 如果指定了行号范围，优先读取指定范围
- 如果没有行号，读取整个文件
- 将读取的内容作为上下文，用于理解问题和修复

### 4. 执行修复

根据选定的修复方案类型，执行代码修复：

#### 4.1 使用 Report 中的方案（推荐方案或指定方案）

**修复步骤**:

1. **理解修复方案**: 仔细阅读选定方案的代码示例和说明
2. **定位修改位置**: 根据 "问题代码位置" 定位需要修改的文件和行号
3. **执行修改**: 使用 Edit 工具进行代码修改
   - 尽量参考方案中提供的代码示例
   - 根据实际文件内容调整代码格式和缩进
   - 可以根据实际情况优化方案中的实现细节
   - 如果方案代码与实际文件有出入，以实际文件为准进行合理调整
4. **验证修改**: 读取修改后的文件片段，确认修改正确

**注意事项**:

- 尽量按照选定方案的核心思路进行修复
- 方案提供的是参考实现，可以根据实际情况适当调整
- 保持代码风格与项目规范一致
- 如果方案中有多处修改，确保核心修改点都完成
- 可以在方案基础上进行合理优化或补充

#### 4.2 使用自定义方案描述

**修复步骤**:

1. **分析修复需求**:
   - 阅读问题描述，理解需要解决的问题
   - 阅读自定义方案描述，理解用户的修复意图
   - 结合相关文档，理解上下文

2. **制定修复计划**:
   - 确定需要修改的文件和位置
   - 确定具体的修改内容
   - 如果方案描述不够详细，基于问题分析推断合理的修复方法
   - 确保修改计划符合项目规范

3. **确认修改计划**:
   - 输出计划并与用户确认
   - 如果用户确认，开始执行修改
   - 如果用户不确认，按照用户要求调整计划

4. **执行修改**:
   - 使用 Edit 工具进行代码修改
   - 确保修改符合自定义方案的意图
   - 保持代码风格和项目规范一致

5. **验证修改**:
   - 读取修改后的文件片段
   - 确认修改达到了自定义方案的目标
   - 确认没有引入新问题

**注意事项**:

- 自定义方案可能只是高层次描述，需要你根据问题分析填充细节
- 确保修复符合项目的编码规范和设计规范
- 如果自定义方案描述不清晰，优先选择最安全、最简单的实现方式
- 在 fix-report.md 中详细说明你是如何理解和实现自定义方案的

### 5. 生成修复报告

修复完成后，创建修复报告文件 `.claude/issues/{issue_id}/fix-report.md`：

**报告格式**:

````markdown
# Issue 修复报告: {Issue 标题}

## 基本信息

- **Issue ID**: {issue_id}
- **修复日期**: {YYYY-MM-DD}
- **采用方案**: {选定的方案编号 或 "自定义方案"}
- **修复状态**: ✅ 已完成

## 修复概要

{简要描述修复了什么问题，使用了什么方案}

## 方案来源

{说明使用的是哪种方案}

**选项 1**: 使用 Report 推荐方案 - {方案编号}
**选项 2**: 使用 Report 指定方案 - {方案编号}
**选项 3**: 使用自定义方案

{如果是自定义方案，需要详细说明：}

- **用户提供的方案描述**: {原始描述}
- **方案理解**: {你如何理解这个方案}
- **实现思路**: {你计划如何实现}

## 修复详情

### 1. 文件修改列表

{列出所有修改的文件及其修改位置}

**修改文件**:

- `{file_path}` - 第 {line_range} 行

### 2. 具体修改内容

{对每个文件的修改进行详细说明}

#### 修改 1: {file_path}

**位置**: 第 {line_range} 行

**修改前**:

```typescript
{
  old_code;
}
```
````

**修改后**:

```typescript
{
  new_code;
}
```

**修改说明**: {解释为什么这样修改}

### 3. 修复效果

{列出修复后达到的效果}

- ✅ {效果1}
- ✅ {效果2}
- ✅ {效果3}

## 验证结果

{如果进行了验证，描述验证过程和结果}

- [ ] 代码编译通过
- [ ] 类型检查通过
- [ ] 符合编码规范
- [ ] 与数据库 Schema 一致

## 后续待办

{从 report 的"后续行动步骤"中提取，列出实际实现时需要完成的事项}

- [ ] {待办事项1}
- [ ] {待办事项2}

---

**修复时间**: {timestamp}
**修复人**: Claude Code

````

### 6. 重命名 Issue 目录

修复完成并生成报告后，将 issue 目录标记为已完成：

**重命名操作**:
```bash
mv ".claude/issues/{issue_id}" ".claude/issues/✅ {issue_id}"
````

**验证**:

- 确认新目录存在
- 确认旧目录已删除
- 输出成功消息

### 7. 输出总结

向用户输出简洁的修复总结：

**输出格式**:

```
✅ Issue {issue_id} 修复完成

**采用方案**: {方案编号}
**修改文件**: {文件数量} 个
**修复报告**: .claude/issues/✅ {issue_id}/fix-report.md

修复内容：
- {简要修复点1}
- {简要修复点2}

该 issue 已标记为已完成：.claude/issues/✅ {issue_id}/
```

## 错误处理

**如果遇到错误**:

1. **Issue 不存在**:

   ```
   ❌ 错误: Issue {issue_id} 不存在
   请检查 issue_id 是否正确，或使用以下命令查看可用的 issues:
   ls .claude/issues/
   ```

2. **方案编号无效**:

   ```
   ❌ 错误: 指定的方案 "{solution_id}" 在 report 中不存在
   可用方案: 方案一, 方案二, 方案三
   ```

3. **修复失败**:
   - 不要重命名目录
   - 在 fix-report.md 中标记失败状态
   - 输出详细错误信息
   - 提示用户手动检查

## 示例

**示例 1: 使用推荐方案修复代码**

```
用户输入: /issue-fix-code P0-003-mindmap-persistence-draft

执行流程:
1. 读取 .claude/issues/P0-003-mindmap-persistence-draft/report.md
2. 发现推荐方案是"方案一"
3. 读取相关代码文件
4. 执行方案一的代码修复（创建 lib/types/persistence.ts，添加类型定义）
5. 生成 fix-report.md
6. 重命名目录为 .claude/issues/✅ P0-003-mindmap-persistence-draft
```

**示例 2: 指定方案编号修复代码**

```
用户输入: /issue-fix-code P0-004-mindmap-persistence-draft 方案二

执行流程:
1. 读取 .claude/issues/P0-004-mindmap-persistence-draft/report.md
2. 识别"方案二"是方案编号
3. 在 report 中查找"方案二"的内容
4. 读取相关代码文件
5. 执行方案二的代码修复
6. 生成 fix-report.md
7. 重命名目录为 .claude/issues/✅ P0-004-mindmap-persistence-draft
```

**示例 3: 使用自定义方案描述修复代码**

```
用户输入: /issue-fix-code C0-001-add-logging 在 lib/utils/ 中创建 logger.ts 工具文件，实现统一的日志记录功能

执行流程:
1. 读取 .claude/issues/C0-001-add-logging/report.md
2. 识别这是自定义方案描述（不包含"方案"关键词）
3. 读取问题描述和相关代码文件
4. 理解自定义方案意图：创建日志工具
5. 定位需要修改的位置：lib/utils/ 目录
6. 执行修改：创建 logger.ts 文件并实现日志功能
7. 生成 fix-report.md（说明如何理解和实现自定义方案）
8. 重命名目录为 .claude/issues/✅ C0-001-add-logging
```

## 注意事项

1. **精确匹配**: Edit 工具要求 old_string 精确匹配，确保从实际文件读取原始代码
2. **多处修改**: 如果一个方案需要修改多个位置，确保全部完成
3. **保持格式**: 保持代码缩进和格式与原文件一致
4. **验证修复**: 修复后读取修改的部分，确认修改正确
5. **详细报告**: fix-report.md 应该包含足够的细节，便于后续审查

## 工作原则

**对于 Report 中的方案**:

- 以方案的核心思路和目标为指导进行修复
- 方案提供的代码示例是参考，可以根据实际情况调整
- 可以在方案基础上进行合理优化或补充
- 如果方案代码与实际文件不匹配，灵活调整以适应实际情况
- 如果方案中有多处修改点，确保核心修改都完成

**对于自定义方案**:

- 仔细理解用户的修复意图
- 结合问题描述和相关文档，制定合理的修复计划
- 确保修复符合项目的编码规范和设计规范
- 在 fix-report.md 中详细说明你是如何理解和实现方案的
- 如果描述不够清晰，选择最合理、最符合项目规范的实现方式

**通用原则**:

- 修复的目标是解决问题，而不是机械复制方案代码
- 保持代码风格与项目规范一致
- 确保所有修改都完成后再生成报告
- 验证修复的正确性和合理性
- 只有修复完全成功后才重命名目录
- 如果修复失败，保持目录原名，并在报告中说明失败原因
